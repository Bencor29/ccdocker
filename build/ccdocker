local function _W(f) local e=setmetatable({}, {__index = getfenv()}) return setfenv(f,e)() or e end
local json=_W(function()
-- -*- coding: utf-8 -*-
--
-- Simple JSON encoding and decoding in pure Lua.
--
-- Copyright 2010-2014 Jeffrey Friedl
-- http://regex.info/blog/
--
-- Latest version: http://regex.info/blog/lua/json
--
-- This code is released under a Creative Commons CC-BY "Attribution" License:
-- http://creativecommons.org/licenses/by/3.0/deed.en_US
--
-- It can be used for any purpose so long as the copyright notice and
-- web-page links above are maintained. Enjoy.
--
local VERSION = 20140923
local json = { VERSION = VERSION }

local isArray  = { __tostring = function() return "JSON array"  end }    isArray.__index  = isArray
local isObject = { __tostring = function() return "JSON object" end }    isObject.__index = isObject


function json:newArray(tbl)
   return setmetatable(tbl or {}, isArray)
end

function json:newObject(tbl)
   return setmetatable(tbl or {}, isObject)
end

local function unicode_codepoint_as_utf8(codepoint)
   --
   -- codepoint is a number
   --
   if codepoint <= 127 then
      return string.char(codepoint)

   elseif codepoint <= 2047 then
      --
      -- 110yyyxx 10xxxxxx         <-- useful notation from http://en.wikipedia.org/wiki/Utf8
      --
      local highpart = math.floor(codepoint / 0x40)
      local lowpart  = codepoint - (0x40 * highpart)
      return string.char(0xC0 + highpart,
                         0x80 + lowpart)

   elseif codepoint <= 65535 then
      --
      -- 1110yyyy 10yyyyxx 10xxxxxx
      --
      local highpart  = math.floor(codepoint / 0x1000)
      local remainder = codepoint - 0x1000 * highpart
      local midpart   = math.floor(remainder / 0x40)
      local lowpart   = remainder - 0x40 * midpart

      highpart = 0xE0 + highpart
      midpart  = 0x80 + midpart
      lowpart  = 0x80 + lowpart

      --
      -- Check for an invalid character (thanks Andy R. at Adobe).
      -- See table 3.7, page 93, in http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#G28070
      --
      if ( highpart == 0xE0 and midpart < 0xA0 ) or
         ( highpart == 0xED and midpart > 0x9F ) or
         ( highpart == 0xF0 and midpart < 0x90 ) or
         ( highpart == 0xF4 and midpart > 0x8F )
      then
         return "?"
      else
         return string.char(highpart,
                            midpart,
                            lowpart)
      end

   else
      --
      -- 11110zzz 10zzyyyy 10yyyyxx 10xxxxxx
      --
      local highpart  = math.floor(codepoint / 0x40000)
      local remainder = codepoint - 0x40000 * highpart
      local midA      = math.floor(remainder / 0x1000)
      remainder       = remainder - 0x1000 * midA
      local midB      = math.floor(remainder / 0x40)
      local lowpart   = remainder - 0x40 * midB

      return string.char(0xF0 + highpart,
                         0x80 + midA,
                         0x80 + midB,
                         0x80 + lowpart)
   end
end

function json:onDecodeError(message, text, location, etc)
   if etc ~= nil then
      message = message .. " (" .. json:encode(etc) .. ")"
   end

   if self.assert then
      self.assert(false, message)
   else
      assert(false, message)
   end
end

json.onDecodeOfNilError  = json.onDecodeError
json.onDecodeOfHTMLError = json.onDecodeError

function json:onEncodeError(message, etc)
   if etc ~= nil then
      message = message .. " (" .. json:encode(etc) .. ")"
   end

   if self.assert then
      self.assert(false, message)
   else
      assert(false, message)
   end
end

local function grok_number(self, text, start, etc)
   --
   -- Grab the integer part
   --
   local integer_part = text:match('^-?[1-9]%d*', start)
                     or text:match("^-?0",        start)

   if not integer_part then
      self:onDecodeError("expected number", text, start, etc)
   end

   local i = start + integer_part:len()

   --
   -- Grab an optional decimal part
   --
   local decimal_part = text:match('^%.%d+', i) or ""

   i = i + decimal_part:len()

   --
   -- Grab an optional exponential part
   --
   local exponent_part = text:match('^[eE][-+]?%d+', i) or ""

   i = i + exponent_part:len()

   local full_number_text = integer_part .. decimal_part .. exponent_part
   local as_number = tonumber(full_number_text)

   if not as_number then
      self:onDecodeError("bad number", text, start, etc)
   end

   return as_number, i
end


local function grok_string(self, text, start, etc)

   if text:sub(start,start) ~= '"' then
      self:onDecodeError("expected string's opening quote", text, start, etc)
   end

   local i = start + 1 -- +1 to bypass the initial quote
   local text_len = text:len()
   local VALUE = ""
   while i <= text_len do
      local c = text:sub(i,i)
      if c == '"' then
         return VALUE, i + 1
      end
      if c ~= '\\' then
         VALUE = VALUE .. c
         i = i + 1
      elseif text:match('^\\b', i) then
         VALUE = VALUE .. "\b"
         i = i + 2
      elseif text:match('^\\f', i) then
         VALUE = VALUE .. "\f"
         i = i + 2
      elseif text:match('^\\n', i) then
         VALUE = VALUE .. "\n"
         i = i + 2
      elseif text:match('^\\r', i) then
         VALUE = VALUE .. "\r"
         i = i + 2
      elseif text:match('^\\t', i) then
         VALUE = VALUE .. "\t"
         i = i + 2
      else
         local hex = text:match('^\\u([0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF])', i)
         if hex then
            i = i + 6 -- bypass what we just read

            -- We have a Unicode codepoint. It could be standalone, or if in the proper range and
            -- followed by another in a specific range, it'll be a two-code surrogate pair.
            local codepoint = tonumber(hex, 16)
            if codepoint >= 0xD800 and codepoint <= 0xDBFF then
               -- it's a hi surrogate... see whether we have a following low
               local lo_surrogate = text:match('^\\u([dD][cdefCDEF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF])', i)
               if lo_surrogate then
                  i = i + 6 -- bypass the low surrogate we just read
                  codepoint = 0x2400 + (codepoint - 0xD800) * 0x400 + tonumber(lo_surrogate, 16)
               else
                  -- not a proper low, so we'll just leave the first codepoint as is and spit it out.
               end
            end
            VALUE = VALUE .. unicode_codepoint_as_utf8(codepoint)

         else

            -- just pass through what's escaped
            VALUE = VALUE .. text:match('^\\(.)', i)
            i = i + 2
         end
      end
   end

   self:onDecodeError("unclosed string", text, start, etc)
end

local function skip_whitespace(text, start)

   local _, match_end = text:find("^[ \n\r\t]+", start) -- [http://www.ietf.org/rfc/rfc4627.txt] Section 2
   if match_end then
      return match_end + 1
   else
      return start
   end
end

local grok_one -- assigned later

local function grok_object(self, text, start, etc)
   if text:sub(start,start) ~= '{' then
      self:onDecodeError("expected '{'", text, start, etc)
   end

   local i = skip_whitespace(text, start + 1) -- +1 to skip the '{'

   local VALUE = self.strictTypes and self:newObject { } or { }

   if text:sub(i,i) == '}' then
      return VALUE, i + 1
   end
   local text_len = text:len()
   while i <= text_len do
      local key, new_i = grok_string(self, text, i, etc)

      i = skip_whitespace(text, new_i)

      if text:sub(i, i) ~= ':' then
         self:onDecodeError("expected colon", text, i, etc)
      end

      i = skip_whitespace(text, i + 1)

      local new_val, new_i = grok_one(self, text, i)

      VALUE[key] = new_val

      --
      -- Expect now either '}' to end things, or a ',' to allow us to continue.
      --
      i = skip_whitespace(text, new_i)

      local c = text:sub(i,i)

      if c == '}' then
         return VALUE, i + 1
      end

      if text:sub(i, i) ~= ',' then
         self:onDecodeError("expected comma or '}'", text, i, etc)
      end

      i = skip_whitespace(text, i + 1)
   end

   self:onDecodeError("unclosed '{'", text, start, etc)
end

local function grok_array(self, text, start, etc)
   if text:sub(start,start) ~= '[' then
      self:onDecodeError("expected '['", text, start, etc)
   end

   local i = skip_whitespace(text, start + 1) -- +1 to skip the '['
   local VALUE = self.strictTypes and self:newArray { } or { }
   if text:sub(i,i) == ']' then
      return VALUE, i + 1
   end

   local VALUE_INDEX = 1

   local text_len = text:len()
   while i <= text_len do
      local val, new_i = grok_one(self, text, i)

      -- can't table.insert(VALUE, val) here because it's a no-op if val is nil
      VALUE[VALUE_INDEX] = val
      VALUE_INDEX = VALUE_INDEX + 1

      i = skip_whitespace(text, new_i)

      --
      -- Expect now either ']' to end things, or a ',' to allow us to continue.
      --
      local c = text:sub(i,i)
      if c == ']' then
         return VALUE, i + 1
      end
      if text:sub(i, i) ~= ',' then
         self:onDecodeError("expected comma or '['", text, i, etc)
      end
      i = skip_whitespace(text, i + 1)
   end
   self:onDecodeError("unclosed '['", text, start, etc)
end


grok_one = function(self, text, start, etc)
   -- Skip any whitespace
   start = skip_whitespace(text, start)

   if start > text:len() then
      self:onDecodeError("unexpected end of string", text, nil, etc)
   end

   if text:find('^"', start) then
      return grok_string(self, text, start, etc)

   elseif text:find('^[-0123456789 ]', start) then
      return grok_number(self, text, start, etc)

   elseif text:find('^%{', start) then
      return grok_object(self, text, start, etc)

   elseif text:find('^%[', start) then
      return grok_array(self, text, start, etc)

   elseif text:find('^true', start) then
      return true, start + 4

   elseif text:find('^false', start) then
      return false, start + 5

   elseif text:find('^null', start) then
      return nil, start + 4

   else
      self:onDecodeError("can't parse JSON", text, start, etc)
   end
end

function json:decode(text, etc)
   if type(self) ~= 'table' or self.__index ~= json then
      json:onDecodeError("JSON:decode must be called in method format", nil, nil, etc)
   end

   if text == nil then
      self:onDecodeOfNilError(string.format("nil passed to JSON:decode()"), nil, nil, etc)
   elseif type(text) ~= 'string' then
      self:onDecodeError(string.format("expected string argument to JSON:decode(), got %s", type(text)), nil, nil, etc)
   end

   if text:match('^%s*$') then
      return nil
   end

   if text:match('^%s*<') then
      -- Can't be JSON... we'll assume it's HTML
      self:onDecodeOfHTMLError(string.format("html passed to JSON:decode()"), text, nil, etc)
   end

   --
   -- Ensure that it's not UTF-32 or UTF-16.
   -- Those are perfectly valid encodings for JSON (as per RFC 4627 section 3),
   -- but this package can't handle them.
   --
   if text:sub(1,1):byte() == 0 or (text:len() >= 2 and text:sub(2,2):byte() == 0) then
      self:onDecodeError("JSON package groks only UTF-8, sorry", text, nil, etc)
   end

   local success, value = pcall(grok_one, self, text, 1, etc)

   if success then
      return value
   else
      -- if JSON:onDecodeError() didn't abort out of the pcall, we'll have received the error message here as "value", so pass it along as an assert.
      if self.assert then
         self.assert(false, value)
      else
         assert(false, value)
      end
      -- and if we're still here, return a nil and throw the error message on as a second arg
      return nil, value
   end
end

local function backslash_replacement_function(c)
   if c == "\n" then
      return "\\n"
   elseif c == "\r" then
      return "\\r"
   elseif c == "\t" then
      return "\\t"
   elseif c == "\b" then
      return "\\b"
   elseif c == "\f" then
      return "\\f"
   elseif c == '"' then
      return '\\"'
   elseif c == '\\' then
      return '\\\\'
   else
      return string.format("\\u%04x", c:byte())
   end
end

local chars_to_be_escaped_in_JSON_string
   = '['
   ..    '"'    -- class sub-pattern to match a double quote
   ..    '%\\'  -- class sub-pattern to match a backslash
   ..    '%z'   -- class sub-pattern to match a null
   ..    '\001' .. '-' .. '\031' -- class sub-pattern to match control characters
   .. ']'

local function json_string_literal(value)
   local newval = value:gsub(chars_to_be_escaped_in_JSON_string, backslash_replacement_function)
   return '"' .. newval .. '"'
end

local function object_or_array(self, T, etc)
   --
   -- We need to inspect all the keys... if there are any strings, we'll convert to a JSON
   -- object. If there are only numbers, it's a JSON array.
   --
   -- If we'll be converting to a JSON object, we'll want to sort the keys so that the
   -- end result is deterministic.
   --
   local string_keys = { }
   local number_keys = { }
   local number_keys_must_be_strings = false
   local maximum_number_key

   for key in pairs(T) do
      if type(key) == 'string' then
         table.insert(string_keys, key)
      elseif type(key) == 'number' then
         table.insert(number_keys, key)
         if key <= 0 or key >= math.huge then
            number_keys_must_be_strings = true
         elseif not maximum_number_key or key > maximum_number_key then
            maximum_number_key = key
         end
      else
         self:onEncodeError("can't encode table with a key of type " .. type(key), etc)
      end
   end

   if #string_keys == 0 and not number_keys_must_be_strings then
      --
      -- An empty table, or a numeric-only array
      --
      if #number_keys > 0 then
         return nil, maximum_number_key -- an array
      elseif tostring(T) == "JSON array" then
         return nil
      elseif tostring(T) == "JSON object" then
         return { }
      else
         -- have to guess, so we'll pick array, since empty arrays are likely more common than empty objects
         return nil
      end
   end

   table.sort(string_keys)

   local map
   if #number_keys > 0 then
      --
      -- If we're here then we have either mixed string/number keys, or numbers inappropriate for a JSON array
      -- It's not ideal, but we'll turn the numbers into strings so that we can at least create a JSON object.
      --

      if self.noKeyConversion then
         self:onEncodeError("a table with both numeric and string keys could be an object or array; aborting", etc)
      end

      --
      -- Have to make a shallow copy of the source table so we can remap the numeric keys to be strings
      --
      map = { }
      for key, val in pairs(T) do
         map[key] = val
      end

      table.sort(number_keys)

      --
      -- Throw numeric keys in there as strings
      --
      for _, number_key in ipairs(number_keys) do
         local string_key = tostring(number_key)
         if map[string_key] == nil then
            table.insert(string_keys , string_key)
            map[string_key] = T[number_key]
         else
            self:onEncodeError("conflict converting table with mixed-type keys into a JSON object: key " .. number_key .. " exists both as a string and a number.", etc)
         end
      end
   end

   return string_keys, nil, map
end

--
-- Encode
--
local encode_value -- must predeclare because it calls itself
function encode_value(self, value, parents, etc, indent) -- non-nil indent means pretty-printing

   if value == nil then
      return 'null'

   elseif type(value) == 'string' then
      return json_string_literal(value)

   elseif type(value) == 'number' then
      if value ~= value then
         --
         -- NaN (Not a Number).
         -- JSON has no NaN, so we have to fudge the best we can. This should really be a package option.
         --
         return "null"
      elseif value >= math.huge then
         --
         -- Positive infinity. JSON has no INF, so we have to fudge the best we can. This should
         -- really be a package option. Note: at least with some implementations, positive infinity
         -- is both ">= math.huge" and "<= -math.huge", which makes no sense but that's how it is.
         -- Negative infinity is properly "<= -math.huge". So, we must be sure to check the ">="
         -- case first.
         --
         return "1e+9999"
      elseif value <= -math.huge then
         --
         -- Negative infinity.
         -- JSON has no INF, so we have to fudge the best we can. This should really be a package option.
         --
         return "-1e+9999"
      else
         return tostring(value)
      end

   elseif type(value) == 'boolean' then
      return tostring(value)

   elseif type(value) ~= 'table' then
      self:onEncodeError("can't convert " .. type(value) .. " to JSON", etc)

   else
      --
      -- A table to be converted to either a JSON object or array.
      --
      local T = value

      if parents[T] then
         self:onEncodeError("table " .. tostring(T) .. " is a child of itself", etc)
      else
         parents[T] = true
      end

      local result_value

      local object_keys, maximum_number_key, map = object_or_array(self, T, etc)
      if maximum_number_key then
         --
         -- An array...
         --
         local ITEMS = { }
         for i = 1, maximum_number_key do
            table.insert(ITEMS, encode_value(self, T[i], parents, etc, indent))
         end

         if indent then
            result_value = "[ " .. table.concat(ITEMS, ", ") .. " ]"
         else
            result_value = "[" .. table.concat(ITEMS, ",") .. "]"
         end

      elseif object_keys then
         --
         -- An object
         --
         local TT = map or T

         if indent then

            local KEYS = { }
            local max_key_length = 0
            for _, key in ipairs(object_keys) do
               local encoded = encode_value(self, tostring(key), parents, etc, "")
               max_key_length = math.max(max_key_length, #encoded)
               table.insert(KEYS, encoded)
            end
            local key_indent = indent .. "    "
            local subtable_indent = indent .. string.rep(" ", max_key_length + 2 + 4)
            local FORMAT = "%s%" .. string.format("%d", max_key_length) .. "s: %s"

            local COMBINED_PARTS = { }
            for i, key in ipairs(object_keys) do
               local encoded_val = encode_value(self, TT[key], parents, etc, subtable_indent)
               table.insert(COMBINED_PARTS, string.format(FORMAT, key_indent, KEYS[i], encoded_val))
            end
            result_value = "{\n" .. table.concat(COMBINED_PARTS, ",\n") .. "\n" .. indent .. "}"

         else

            local PARTS = { }
            for _, key in ipairs(object_keys) do
               local encoded_val = encode_value(self, TT[key],       parents, etc, indent)
               local encoded_key = encode_value(self, tostring(key), parents, etc, indent)
               table.insert(PARTS, string.format("%s:%s", encoded_key, encoded_val))
            end
            result_value = "{" .. table.concat(PARTS, ",") .. "}"

         end
      else
         --
         -- An empty array/object... we'll treat it as an array, though it should really be an option
         --
         result_value = "[]"
      end

      parents[T] = false
      return result_value
   end
end


function json:encode(value, etc)
   if type(self) ~= 'table' or self.__index ~= json then
      json:onEncodeError("JSON:encode must be called in method format", etc)
   end
   return encode_value(self, value, {}, etc, nil)
end

function json:encode_pretty(value, etc)
   if type(self) ~= 'table' or self.__index ~= json then
      json:onEncodeError("JSON:encode_pretty must be called in method format", etc)
   end
   return encode_value(self, value, {}, etc, "")
end

function json.__tostring()
   return "JSON encode/decode package"
end

json.__index = json

function json:new(args)
   local new = { }

   if args then
      for key, val in pairs(args) do
         new[key] = val
      end
   end

   return setmetatable(new, json)
end

return json:new()
end)
local sha256=_W(function()
--
--  Adaptation of the Secure Hashing Algorithm (SHA-244/256)
--  Found Here: http://lua-users.org/wiki/SecureHashAlgorithm
--
--  Using an adapted version of the bit library
--  Found Here: https://bitbucket.org/Boolsheet/bslf/src/1ee664885805/bit.lua
--

local MOD = 2^32
local MODM = MOD-1

local function memoize(f)
        local mt = {}
        local t = setmetatable({}, mt)
        function mt:__index(k)
                local v = f(k)
                t[k] = v
                return v
        end
        return t
end

local function make_bitop_uncached(t, m)
        local function bitop(a, b)
                local res,p = 0,1
                while a ~= 0 and b ~= 0 do
                        local am, bm = a % m, b % m
                        res = res + t[am][bm] * p
                        a = (a - am) / m
                        b = (b - bm) / m
                        p = p*m
                end
                res = res + (a + b) * p
                return res
        end
        return bitop
end

local function make_bitop(t)
        local op1 = make_bitop_uncached(t,2^1)
        local op2 = memoize(function(a) return memoize(function(b) return op1(a, b) end) end)
        return make_bitop_uncached(op2, 2 ^ (t.n or 1))
end

local bxor1 = make_bitop({[0] = {[0] = 0,[1] = 1}, [1] = {[0] = 1, [1] = 0}, n = 4})

local function bxor(a, b, c, ...)
        local z = nil
        if b then
                a = a % MOD
                b = b % MOD
                z = bxor1(a, b)
                if c then z = bxor(z, c, ...) end
                return z
        elseif a then return a % MOD
        else return 0 end
end

local function band(a, b, c, ...)
        local z
        if b then
                a = a % MOD
                b = b % MOD
                z = ((a + b) - bxor1(a,b)) / 2
                if c then z = bit32_band(z, c, ...) end
                return z
        elseif a then return a % MOD
        else return MODM end
end

local function bnot(x) return (-1 - x) % MOD end

local function rshift1(a, disp)
        if disp < 0 then return lshift(a,-disp) end
        return math.floor(a % 2 ^ 32 / 2 ^ disp)
end

local function rshift(x, disp)
        if disp > 31 or disp < -31 then return 0 end
        return rshift1(x % MOD, disp)
end

local function lshift(a, disp)
        if disp < 0 then return rshift(a,-disp) end
        return (a * 2 ^ disp) % 2 ^ 32
end

local function rrotate(x, disp)
    x = x % MOD
    disp = disp % 32
    local low = band(x, 2 ^ disp - 1)
    return rshift(x, disp) + lshift(low, 32 - disp)
end

local k = {
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
        0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
        0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
        0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
        0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
        0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
        0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
        0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
        0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
}

local function str2hexa(s)
        return (string.gsub(s, ".", function(c) return string.format("%02x", string.byte(c)) end))
end

local function num2s(l, n)
        local s = ""
        for i = 1, n do
                local rem = l % 256
                s = string.char(rem) .. s
                l = (l - rem) / 256
        end
        return s
end

local function s232num(s, i)
        local n = 0
        for i = i, i + 3 do n = n*256 + string.byte(s, i) end
        return n
end

local function preproc(msg, len)
        local extra = 64 - ((len + 9) % 64)
        len = num2s(8 * len, 8)
        msg = msg .. "\128" .. string.rep("\0", extra) .. len
        assert(#msg % 64 == 0)
        return msg
end

local function initH256(H)
        H[1] = 0x6a09e667
        H[2] = 0xbb67ae85
        H[3] = 0x3c6ef372
        H[4] = 0xa54ff53a
        H[5] = 0x510e527f
        H[6] = 0x9b05688c
        H[7] = 0x1f83d9ab
        H[8] = 0x5be0cd19
        return H
end

local function digestblock(msg, i, H)
        local w = {}
        for j = 1, 16 do w[j] = s232num(msg, i + (j - 1)*4) end
        for j = 17, 64 do
                local v = w[j - 15]
                local s0 = bxor(rrotate(v, 7), rrotate(v, 18), rshift(v, 3))
                v = w[j - 2]
                w[j] = w[j - 16] + s0 + w[j - 7] + bxor(rrotate(v, 17), rrotate(v, 19), rshift(v, 10))
        end

        local a, b, c, d, e, f, g, h = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]
        for i = 1, 64 do
                local s0 = bxor(rrotate(a, 2), rrotate(a, 13), rrotate(a, 22))
                local maj = bxor(band(a, b), band(a, c), band(b, c))
                local t2 = s0 + maj
                local s1 = bxor(rrotate(e, 6), rrotate(e, 11), rrotate(e, 25))
                local ch = bxor (band(e, f), band(bnot(e), g))
                local t1 = h + s1 + ch + k[i] + w[i]
                h, g, f, e, d, c, b, a = g, f, e, d + t1, c, b, a, t1 + t2
        end

        H[1] = band(H[1] + a)
        H[2] = band(H[2] + b)
        H[3] = band(H[3] + c)
        H[4] = band(H[4] + d)
        H[5] = band(H[5] + e)
        H[6] = band(H[6] + f)
        H[7] = band(H[7] + g)
        H[8] = band(H[8] + h)
end

local function sha256(msg)
        msg = preproc(msg, #msg)
        local H = initH256({})
        for i = 1, #msg, 64 do digestblock(msg, i, H) end
        return str2hexa(num2s(H[1], 4) .. num2s(H[2], 4) .. num2s(H[3], 4) .. num2s(H[4], 4) ..
                num2s(H[5], 4) .. num2s(H[6], 4) .. num2s(H[7], 4) .. num2s(H[8], 4))
end

return sha256
end)
local docker=_W(function()
--[[
  Introcuding, docker. For computercraft

  @author RainbowDashDC <rainbowdashdc@pony.so>
  @version 0.1.1 (sematic)
  @license MIT
]]

-- helper functions
local function deepcopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[deepcopy(orig_key)] = deepcopy(orig_value)
        end
        setmetatable(copy, deepcopy(getmetatable(orig)))
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end

-- tokenise
local function tokenise( ... )
    local sLine = table.concat( { ... }, " " )
	local tWords = {}
    local bQuoted = false
    for match in string.gmatch( sLine .. "\"", "(.-)\"" ) do
        if bQuoted then
            table.insert( tWords, match )
        else
            for m in string.gmatch( match, "[^ \t]+" ) do
                table.insert( tWords, m )
            end
        end
        bQuoted = not bQuoted
    end
    return tWords
end

-- split a string
function string:split(delimiter)
  local result = { }
  local from  = 1
  local delim_from, delim_to = string.find( self, delimiter, from  )
  while delim_from do
    table.insert( result, string.sub( self, from , delim_from-1 ) )
    from  = delim_to + 1
    delim_from, delim_to = string.find( self, delimiter, from  )
  end
  table.insert( result, string.sub( self, from  ) )
  return result
end

-- The JavaScript-like syntax is real.
local docker = {}
docker.fs = {}
docker.shell = {}
docker.version = "0.1.1"

docker.init = function(this)
  docker.checkArgs(this)
end

docker.checkArgs = function(this)
  if this == nil then
    error("call with :")
  end
end

docker.pullImage = function(this)
  docker.checkArgs(this)
end

docker.dPrint = function(this, msg)
  local h = fs.open("docker.log", "a")
  h.write(tostring(msg).."\n")
  h.close()

  return nil -- nothing for now
end

docker.genFS = function(this, file)
  if fs.exists(file) ~= true then
    this:dPrint("fs: generating fs db")

    fo = {}

    -- init script aka entrypoint
    fo.init = ""

    -- manifest
    fo.m = {}
    fo.m.s = 10000
    fo.m.files = 0
    fo.m.dirs = 0
    fo.m.version = 002

    -- inode container
    fo.i = {}

    -- root
    fo.i[""] = {}
    fo.i[""].isDir = true
    fo.i[""].c = {}
    fo.i[""].s = 0

    local fstr = fs.open(file, "w")
    fstr.write(json:encode(fo))
    fstr.close()
    fstr = nil -- erase it, mark for gc.

    this:dPrint("fs: generated")
  end
end

docker.fs.exists = function (this, f)
  this:dPrint("fs: checking if '"..fs.combine(tostring(""), tostring(f)).."' exists")
  if this.fo.i[fs.combine("", f)] == nil then
    this:dPrint("fs: "..fs.combine("", f).." doesn't exist")
    return false
  end

  this:dPrint("fs: it exists")
  -- probably exists
  return true
end

docker.fs.isdir = function (this, d)
  -- per specs, if it doesn't exist return false
  if this.fs.exists(this, d) ~= true then
    return false
  end

  if this.fo.i[fs.combine("", d)].isDir == false then
    return false
  end

  -- return true as it must be a dir
  return true
end

-- non-standard function, is internal.
docker.fs.addchild = function (this, d, i)
  this:dPrint("fs: [addchild] parent = "..tostring(d).." inode = "..tostring(i))

  -- per specs, do nothing if it exists
  if this.fs.exists(this, d) == false then
    error("parent not found")
    return nil
  end

  if this.fs.exists(this,i) == false then
    error("child not found")
    return nil
  end

  if this.fs.isdir(this, d) == false then
    error("isn't directory")
    return nil
  end

  for k, v in ipairs(this.fo.i[fs.combine("", d)].c) do
    if v == tostring(fs.getName(i)) then
      this:dPrint("fs: child already exists.")
      return nil
    end
  end

  -- prepend the file.
  table.insert(this.fo.i[fs.combine("", d)].c, fs.getName(i))
end

docker.fs.list = function (this, d)
  -- per specs, do nothing if it exists
  if this.fs.exists(this,d) == false then
    error("File not found")
    return nil
  end

  for k,v in ipairs(this.fo.i[fs.combine("", d)].c) do
    this:dPrint("fs: list: "..tostring(v))
  end

  return this.fo.i[fs.combine("", d)].c
end

docker.fs.makedir = function (this, d)
  -- per specs, do nothing if it exists
  if this.fs.exists(this,d) == true then
    this:dPrint("fs: dir '"..d.."' already exists")
    return nil
  end

  this:dPrint("fs: making dir '"..fs.combine("", d).."'")

  local sb = string.split(d, "/")

  local filename = nil
  local previous = ""

  -- make the dir
  no = {}
  no.s = 0
  no.c = {}
  no.n = filename
  no.isDir = true

  this.fo.i[fs.combine("", d)] = no

  this:dPrint("fs: incrementing fs.manifest.dirs +1")
  this.fo.m.dirs = this.fo.m.dirs+1

  -- return nil anyways
  return nil
end

docker.fs.write = function (this, f, d)
  local sb = string.split(f, "/")

  -- scope
  local previous = ""
  for k, v in ipairs(sb) do
    if v == "" then
      this:dPrint("fs: is root leading slash")
    else
      if k ~= #sb then -- don't make a dir for the actual file
        this:dPrint("fs: [write] recurv making dir")

        this:dPrint("fs: [write] v = "..tostring(v))
        this:dPrint("fs: [write] previous = "..tostring(previous))

        if this.fs.exists(this, fs.combine(previous, v)) then
          this:dPrint(previous)
          this:dPrint(fs.combine(previous, v))
          this.fs.addchild(this, previous, fs.combine(previous, v))
        end

        this.fs.makedir(this, fs.combine(previous, v)) -- recursivly make dirs, as per specs
        previous = fs.combine(previous, v) -- build a stack.
        this.dPrint(this, previous)
      else
        this.dPrint(this, "fs: recieved file name, not making dir")
      end
    end
  end

  this:dPrint("fs: [write] f = "..tostring(f))

  if this.fs.exists(this, f) == false then
    this:dPrint("fs: incrementing manifest.files +1")
    this.fo.m.files = this.fo.m.files+1
  end

  local filename = nil
  for k, v in ipairs(sb) do
    if k == #sb then
      filename = v
    end
  end

  -- file object
  no = {}
  no.isDir = false
  no.s = 0
  no.n = filename
  no.data = base64.encode(d)

  this.fo.i[fs.combine("", f)] = no

  -- add the child
  this.fs.addchild(this, previous, f)

  -- as per the cc specs
  return nil
end

docker.fs.readAll = function (this, f)
  if this.fs.exists(this, f) ~= true then
    return nil
  end

  return base64.decode(this.fo.i[fs.combine("", f)].data)
end

docker.fs.getSize = function (this, f)
  if this.fs.exists(this,f) ~= true then
    error("No such file")
  end

  if this.fo.i[f].s < 512 then
    return 512
  else
    return (this.fo.i[f].s + this.fo.i[f].n)
  end
end

docker.fs.copy = function (this, fp, tp)
  if this.fs.exists(this,fp) ~= true then
    error("No such file")
  end

  if this.fs.exists(this,tp) == true then
    error("File exists")
  end

  this:dPrint("fs: copying "..fp.." to "..tp)

  this.fo.i[fs.combine("", tp)] = deepcopy(this.fo.i[fs.combine("", fp)])

  return nil
end

docker.fs.delete = function (this, p)
  if this.fs.exists(this,p) ~= true then
    error("No such file")
  end

  this:dPrint("fs: delete '"..fs.combine("", p).."'")

  this.fo.i[fs.combine("", p)] = nil -- remove it

  return nil
end

docker.fs.close = function ()
  fstr = fs.open(image, "w")
  fstr.write(json:encode(fo))
  fstr.close()
end

docker.fs.move = function (this, fp, tp)
  if this.fs.exists(this,fp) ~= true then
    error("No such file")
  end

  if this.fs.exists(this,tp) == true then
    error("File exists")
  end

  this.fo.i[fs.combine("", tp)] = deepcopy(this.fo.i[fp])
  this.fo.i[fs.combine("", fp)] = nil -- remove it.

  return true
end

--[[
  chroot an origin image so it is "localized".
]]
docker.chroot = function(this, image)
  docker.checkArgs(this, image)

  if fs.exists(tostring(image)) == false then
    error("image not found")
  end

  -- fs
  local fstr = fs.open(image, "r")
  this.fo = json:decode(fstr.readAll())
  fstr.close()

  -- build the "chroot" enviroment
  env = {
      -- important functions
      ["print"] = print,
      ["printError"] =  printError,
      ["write"]      = write,
      ["dofile"] = function(path)
        if this.fs.exists(this, path) == false then
          error("No such file")
        end

        if this.fs.isdir(this, path) then
          error("Is directory")
        end

        this:dPrint("dofile: "..path)

        fc = this.fs.readAll(this, path)
        f = loadstring(fc)
        setfenv(f, getfenv(2))
        f() -- execute it
      end,
      ["loadstring"] = deepcopy(loadstring),
      ["ipairs"]    = ipairs,
      ["pairs"]     = pairs,
      ["setfenv"]   = setfenv, -- for now
      ["getfenv"]   = function()
        return env
      end, -- for now as well
      ["pcall"]     = pcall, -- for now
      ["xpcall"]    = xpcall,
      ["type"]      = type,
      ["tonumber"]  = tonumber,
      ["tostring"]  = tostring,
      ["setmetatable"] = setmetatable,
      ["rawequal"] = rawequal,
      ["rawset"] = rawset,
      ["rawget"] = rawget,
      ["select"] = select,
      ["pcall"]  = pcall,
      ["next"]   = next,
      ["unpack"] = unpack,
      ["pack"]   = pack,
      ["error"]  = error,
      ["read"]   = read,

      -- important tables
      ["coroutine"] = deepcopy(coroutine),
      ["string"]    = {
        byte = string.byte,
        dump = function()
          return nil -- return nil since we don't do bytecode.
        end,
        char = string.char,
        find = string.find,
        format = string.format,
        gmatch = string.gmatch,
        gsub = string.gsub,
        len = string.len,
        lower = string.lower,
        match = string.match,
        rep = string.rep,
        reverse = string.reverse,
        sub = string.sub,
        upper = string.upper
      },
      ["table"]     = table,
      ["math"]      = math,
      ["term"]      = term,
      ["colors"]    = colors,
      ["textutils"] = textutils,
      ["colours"]   = colours,
      ["io"]        = {
        open = function(file, mode)
          if mode == nil then -- default is r
            this:dPrint("io: no mode given, using default r")
            mode = "r"
          end

          this:dPrint("io: open "..tostring(file).." with mode "..tostring(mode))

          fobj = {}
          fobj.file = file
          fobj.mode = mode

          local oFile = file
          local oMode = mode


          function fobj.write(that, data)
            local file = oFile
            local mode = oMode

            this:dPrint("write data to "..file)

            -- write the data
            return this.fs.write(this, file, data)
          end

          local i = 0;
          function fobj.read(that, delim)
            local file = file

            this:dPrint("io: [read] called.")

            fc = this.fs.readAll(this, file)

            if delim == "*a" then
              return fc
            end

            local s = string.split(fc, "\n")
            i = i + 1
            this:dPrint("io: [read] line threshold is "..i)
            for k, v in ipairs(s) do
                if k == i then
                  this:dPrint("io: [read] return "..tostring(v))
                  return tostring(v)
                end
            end

            return nil
          end

          function fobj.close(that)
            local file = oFile
            local mode = oMode

            -- this.fs.close(this)

            this:dPrint("close file handle on "..file)
          end

          function fobj.lines(that)
            local file = file

            fc = this.fs.readAll(this, file)

            local i = 0;
            return coroutine.wrap(function()
              local s = string.split(fc, "\n")
              for k, v in ipairs(s) do
                i = i+1
                if k == i then
                  this:dPrint("io: [lines] return "..tostring(v))
                  coroutine.yield(v)
                end
              end
            end)
          end

          return fobj;
        end
      },
      ["os"]        = deepcopy(os),
      ["http"]      = deepcopy(http),
      ["pocket"]    = pocket,
      ["help"]      = deepcopy(help),
      ["multishell"] = deepcopy(multishell),
      ["peripheral"] = deepcopy(peripheral),
      ["debug"]     = {}, -- reset it.

      -- docker specific tables
      ["json"] = json,
      ["base64"] = base64,
      ["docker"] = {
        version = docker.version
      },

      -- I/O hijack (uses a JSON light FS)
      ["fs"] = {
        open = function(file, mode)
          this:dPrint("fs: open "..file.." with mode "..mode)

          fobj = {}

          local oFile = file
          local oMode = mode

          function fobj.write(data)
            local file = oFile
            local mode = oMode

            this:dPrint("write data to "..file)

            -- write the data
            return this.fs.write(this, file, data)
          end

          function fobj.readAll()
            local file = file
            local mode = mode

            return this.fs.readAll(this, file)
          end

          function fobj.close()
            local file = oFile
            local mode = oMode

            this.fs.close(this)

            this:dPrint("close file handle on "..file)
          end

          return fobj;
        end,
        exists = function(file)
          this:dPrint("checking if '"..file.."' file exists")
          return this.fs.exists(this, file)
        end,
        isDir = function(dir)
          return this.fs.isdir(this, dir)
        end,
        makeDir = function(dir)
          return this.fs.makedir(this, dir)
        end,
        combine = fs.combine,
        isReadOnly = function(file)
          return false -- can't see us needing this.
        end,
        getSize = function(file)
          return this.fs.getSize(this, file)
        end,
        getName = fs.getName,
        getDir = fs.getDir,
        getDrive = function(path)
          if this.fs.exists(this, path) then
            return "hdd"
          else
            return nil
          end
        end,
        delete = function(path)
          return this.fs.delete(this, path)
        end,
        copy = function(from, to)
          if from == nil or to == nil then
            error("missing params")
          end

          return this.fs.copy(this, from, to)
        end,
        move = function(from, to)
          if from == nil or to == nil then
            error("missing params")
          end

          return this.fs.move(this, from, to)
        end,
        list = function(directory)
          return this.fs.list(this, directory)
        end,
        getFreeSpace = function()
          error("fs.getFreeSpace not implemented.")
        end
      }
  }

  -- os hijacks
  env.os.loadAPI = function(path)
    if this.fs.exists(this, path) == false then
      error("File not found")
    end

    if this.fs.isdir(this, path) then
      error("Is directory")
    end

    local sName = fs.getName(path)
    local tEnv = {}
    setmetatable(tEnv, { __index = env})
    local fnAPI, err = loadstring(this.fs.readAll(this, path))
    if fnAPI then
      setfenv(fnAPI, tEnv)
      local ok, err = pcall(fnAPI)
      if not ok then
        error(path..":"..err)
      end
    end

    -- extract out the context
    local tAPI = {}
    for k,v in ipairs(tEnv) do
      this:dPrint(k)
      this:dPrint(tostring(v))
    end

    for k,v in pairs(tEnv) do
      if k ~= "_ENV" then
        this:dPrint("os: "..sName..": register method '"..tostring(k).."'")
        tAPI[k] =  v
      end
    end

    this:dPrint("os: register API "..sName)
    env[sName] = tAPI -- this loads it into the namespace.

    return true
  end

  env.os.run = function(tenv, path, ...)
    local file = nil
    local params = tokenise(...)
    local oenv = nil

    this:dPrint("os: params: "..tostring(tenv).." "..tostring(path).." "..tostring(params))
    if type(tenv) ~= "string" then
      file = path
      oenv = tenv
      this:dPrint("os: given enviroment.")

      -- fill unused with originals
      this:dPrint("os: enviroment index set to env")
      setmetatable(oenv, { __index = env})
    else
      this:dPrint("os: using env for enviroment")
      oenv = env
      file = tenv
    end

    if this.fs.exists(this, file) == false then
      return nil
    end

    this:dPrint("os: run "..tostring(file))

    local o = loadstring(this.fs.readAll(this, file))
    setfenv(o, oenv)
    o(unpack(params))
  end

  -- global hijack?
  env._G = env

  if this.fs.exists(this, this.fo.init) ~= true then
    error("image init doesn't exist")
  end

  -- load the files contents
  local o = loadstring(this.fs.readAll(this, this.fo.init))
  setfenv(o, env)

  print("ccdocker: running "..this.fo.name..":"..this.fo.version)
  print("ccdocker: invoke init => "..this.fo.init)

  -- call it.
  this:dPrint("init: execute "..tostring(this.fo.init))
  o()
end

--[[
  TODO: Use standardized FS functions, not locales.
]]
docker.makeImage = function(this, dir)
  docker.checkArgs(this, dir)

  if fs.exists(dir) == false then
    error("directory not found")
  end

  if fs.exists(fs.combine(dir, "CCDockerfile")) == false then
    error("CCDockerfile not found")
  end

  fh = io.open(fs.combine(dir, "CCDockerfile"), "r")

  local name, version, maintainer
  local i = 0
  for line in fh:lines() do
    i = i+1 -- line number

    -- loop locals
    local cmd = string.match(line, "([A-Z]+)")
    local arg = string.match(line, " (.+)")

    -- most important ones
    if i == 1 then
      if cmd ~= "NAME" then
        error("line 1, expected NAME")
      else
        name = arg
      end
    elseif i == 2 then
      if cmd ~= "VERSION" then
        error("line 2, expected VERSION")
      else
        version = arg
      end
    elseif i == 3 then
      if cmd ~= "MAINTAINER" then
        error("line 3, expected MAINTAINER")
      else
        maintainer = arg

        -- end the loop, we're out of giving fucks.
        break
      end
    end
  end

  if fs.exists(fs.combine(dir, "rootfs.ccdocker.fs")) then
    print("NOTICE: removing old fs")
    fs.delete(fs.combine(dir, "rootfs.ccdocker.fs"))
  end

  print("building "..name..":"..version)
  this.genFS(this, fs.combine(dir, "rootfs.ccdocker.fs"))

  local fhhh = fs.open(fs.combine(dir, "rootfs.ccdocker.fs"), "r")
  this.fo = json:decode(fhhh.readAll())
  fhhh.close()

  -- parse the manifest again.
  for line in fh:lines() do
    i = i+1 -- line number

    -- loop locals
    local cmd = string.match(line, "([A-Z]+)")
    local arg = string.match(line, " (.+)")

    -- walk function, omfg it's buggy guys
    local i = 0
    local files = {}
    function walk(direct, from, to)
      for k, c in pairs(fs.list(direct)) do
        if fs.isDir(fs.combine(direct, c)) ~= false then
          walk(fs.combine(direct, c), from, to)
        else
          local a = string.sub(direct, #dir, #direct)
          local b = string.gsub(a, "/"..from, to)

          table.insert(files, {
            odir = direct,
            rdir = b,
            name = c
          })
        end
      end
    end

    if cmd == "ADD" then
      local from = string.match(arg, "([a-zA-Z/]+)")
      local to = string.match(arg, " (.+)")

      print("ADD "..from.." TO "..to)

      -- pre-processing
      if to == "/" then
        to = ""
      end

      if fs.exists(fs.combine(dir, from)) == false then
        error("file not found")
      end

      local start = string.match(os.clock(), "([0-9]+)\.")

      -- TODO: Only walk when fs.isDir()
      walk(fs.combine(dir, from), from, to)

      for i, v in ipairs(files) do
        if fs.exists(fs.combine(v.odir, v.name)) == false then
          error("an error occured [ERRNOTEXISTLOOP]")
        end

        local time_s = string.match(os.clock(), "([0-9]+)\.")

        if math.floor(time_s - start) > 3 then
          print("NOTICE: Yeilding for 1 second.")
          os.sleep(0)
          start = string.match(os.clock(), "([0-9]+)\.")
          print("NOTICE: Yeild finished.")
        end

        -- read the file
        local ch = fs.open(fs.combine(v.odir, v.name), "r")
        local c = ch.readAll()
        ch.close()

        this.fs.write(this, fs.combine(v.rdir, v.name), c)
      end
    elseif cmd == "ENTRYPOINT" then
      this.fo.init = tostring(arg)

      print("ccdocker: register entrypoint: "..arg)
    end
  end

  print("ccdocker: set name       = "..tostring(name))
  this.fo.name = name
  print("ccdocker: set maintainer = "..tostring(maintainer))
  this.fo.maintainer = maintainer
  print("ccdocker: set version    = "..tostring(version))
  this.fo.version = version

  print("ccdocker: write to file")
  local ffh = fs.open(fs.combine(dir, "rootfs.ccdocker.fs"), "w")
  ffh.write(json:encode(this.fo))
  ffh.close()

  print("finished.")
end

-- initialize the ccdocker library
docker:init()

return docker
end)
 --[[
 Make a docker image!

 Author: Jared Allard <rainbowdashdc@pony.so>
 License: MIT
 Version: 0.0.1
]]

-- fcs16
local fcs16 = {}

fcs16["table"] = {
[0]=0, 4489, 8978, 12955, 17956, 22445, 25910, 29887,
35912, 40385, 44890, 48851, 51820, 56293, 59774, 63735,
4225, 264, 13203, 8730, 22181, 18220, 30135, 25662,
40137, 36160, 49115, 44626, 56045, 52068, 63999, 59510,
8450, 12427, 528, 5017, 26406, 30383, 17460, 21949,
44362, 48323, 36440, 40913, 60270, 64231, 51324, 55797,
12675, 8202, 4753, 792, 30631, 26158, 21685, 17724,
48587, 44098, 40665, 36688, 64495, 60006, 55549, 51572,
16900, 21389, 24854, 28831, 1056, 5545, 10034, 14011,
52812, 57285, 60766, 64727, 34920, 39393, 43898, 47859,
21125, 17164, 29079, 24606, 5281, 1320, 14259, 9786,
57037, 53060, 64991, 60502, 39145, 35168, 48123, 43634,
25350, 29327, 16404, 20893, 9506, 13483, 1584, 6073,
61262, 65223, 52316, 56789, 43370, 47331, 35448, 39921,
29575, 25102, 20629, 16668, 13731, 9258, 5809, 1848,
65487, 60998, 56541, 52564, 47595, 43106, 39673, 35696,
33800, 38273, 42778, 46739, 49708, 54181, 57662, 61623,
2112, 6601, 11090, 15067, 20068, 24557, 28022, 31999,
38025, 34048, 47003, 42514, 53933, 49956, 61887, 57398,
6337, 2376, 15315, 10842, 24293, 20332, 32247, 27774,
42250, 46211, 34328, 38801, 58158, 62119, 49212, 53685,
10562, 14539, 2640, 7129, 28518, 32495, 19572, 24061,
46475, 41986, 38553, 34576, 62383, 57894, 53437, 49460,
14787, 10314, 6865, 2904, 32743, 28270, 23797, 19836,
50700, 55173, 58654, 62615, 32808, 37281, 41786, 45747,
19012, 23501, 26966, 30943, 3168, 7657, 12146, 16123,
54925, 50948, 62879, 58390, 37033, 33056, 46011, 41522,
23237, 19276, 31191, 26718, 7393, 3432, 16371, 11898,
59150, 63111, 50204, 54677, 41258, 45219, 33336, 37809,
27462, 31439, 18516, 23005, 11618, 15595, 3696, 8185,
63375, 58886, 54429, 50452, 45483, 40994, 37561, 33584,
31687, 27214, 22741, 18780, 15843, 11370, 7921, 3960 }

function fcs16.hash(str) -- Returns FCS16 Hash of @str
    local i
    local l=string.len(str)
    local uFcs16 = 65535
    for i = 1,l do
        uFcs16 = bit.bxor(bit.brshift(uFcs16,8), fcs16["table"][bit.band(bit.bxor(uFcs16, string.byte(str,i)), 255)])
    end
    return  bit.bxor(uFcs16, 65535)
end

-- Arguments
local Args = {...}

-- config
local server = "73.42.212.100"

local oprint = print
local write = term.write

-- quick colors hijack
local function print(msg, color)
  if color ~= nil then
    term.setTextColor(colors[color])
  end

  oprint(msg)

  if color ~= nil then
    term.setTextColor(colors.white)
  end
end

term.write = function (msg, color)
  if color ~= nil then
    term.setTextColor(colors[color])
  end

  write(msg)

  if color ~= nil then
    term.setTextColor(colors.white)
  end
end

local function doHelp()
  print("USAGE: ccdocker [OPTIONS] COMMAND [arg...]")
  print("")
  print("A self contained runtime for computercraft code.")
  print("")
  print("Commands: ")
  print(" pull     Pull an image from a ccDocker repository")
  print(" push     Push an image to a ccDocker repository")
  print(" build    Build an image.")
  print(" run      Run a command in a new container.")
  print(" register Register on a ccDocker repository.")
  print(" version  Show the ccdocker version.")
  print(" help     Show this help")
end

local function buildImage(image)
  if image == nil then
    error("missing param 1 (image)")
  end

  docker.makeImage(docker, image)
end

local function pullImage(url, image)
  if http == nil then
    error("http not enabled")
  end

  if url == nil then
    error("missing param 0 (url)")
  elseif image == nil then
    error("missing param 1 (image)")
  end

  -- use fs.combine to make parsing a bit easier.
  local url = "http://" .. fs.combine(tostring(url), "")
  local apiv = http.get(url.."/api/version")

  if apiv == nil then
    term.write("FATA", "red")
    print("[0001] Couldn't communicate with the API.")

    return false
  end

  -- determine if we were given a flag.
  local v = string.match(image, ".+:([0-9\.a-zA-Z]+)")
  local s = string.match(image, "(.+):[0-9\.a-zA-Z]+")

  if v == nil then
    vh = ""
    v = "latest"
    s = image
  else
    vh = v..": "
    image = s .. "/" .. v
  end

  local user = string.match(s, "(.+)/.+")
  local img = string.match(s, ".+/(.+)")

  print(vh.."Pulling image "..tostring(s))
  local fh = fs.open(image, "r")
  local r = http.get(url.."/pull/"..image)

  -- check if nil before attempting to parse it.
  if r == nil then
    term.write("FATA", "red")
    print("[0008] Error: image "..tostring(s).." not found")

    return false
  end

  -- newline
  print("")

  -- temporary notice about multiple fs layers not being supported
  term.write("NOTI", "cyan")
  print("[0001] Multiple FS layers is not currently supported.")

  -- check and make sure the result was not nil
  local fc = r.readAll()
  if tostring(fc) == "" then
    term.write("FATA", "red")
    print("[0004] Error: Image was blank.")

    return false
  end

  if fs.exists("/var/ccdocker") then
    fs.makeDir("/var")
    fs.makeDir("/var/ccdocker")
  end

  if fs.exists("/var/ccdocker/"..user.."/"..img.."/"..v.."/docker.fs") then
    fs.delete("/var/ccdocker/"..user.."/"..img.."/"..v.."/docker.fs")
  end

  local fh = fs.open("/var/ccdocker/"..user.."/"..img.."/"..v.."/docker.fs", "w")
  fh.write(fc)
  fh.close()

  local f16h = fcs16.hash(fc)
  print("")
  print("Digest: fcs16:"..f16h)
  print("Status: Downloaded newer image for "..tostring(img)..":"..tostring(v))

  return true
end

local function pushImage(url, image)
  if http == nil then
    error("http not enabled")
  end

  if url == nil then
    error("missing param 0 (url)")
  elseif image == nil then
    error("missing param 1 (image)")
  end

  if fs.exists(image) == false then
    error("image not found")
  end

  -- use fs.combine to make parsing a bit easier.
  local url = "http://" .. fs.combine(tostring(url), "")
  local apiv = http.get(url.."/api/version")

  if apiv == nil then
    term.write("FATA", "red")
    print("[0001] Couldn't communicate with the API.")

    return false
  end

  term.write("Username: ", "lightGray")
  local un = read()

  term.write("Password: ", "lightGray")
  local pass = read("*")

  term.write("checking credentials ... ")
  local r = http.post(url.."/auth", json:encode({
    username = un,
    password = sha256(pass)
  }))

  -- decode and then close the io stream
  local rf =  json:decode(r.readAll())
  r.close()

  if rf ~= nil then
    if rf.token ~= nil then
      print("OK", "green")
    else
      print("FAIL", "red")
      term.write("FATA", "red")
      print("[0009] Error: Couldn't authenticate. Wrong password?")

      return false
    end
  else
    print("FAIL", "red")
    term.write("FATA", "red")
    print("[0010] Bad API response.")

    return false
  end


  term.write("uploading image ... ")
  local fh = fs.open(image, "r")
  local r = http.post(url.."/push", un..":"..rf.token.."\n"..fh.readAll())

  -- preparse check
  if r == nil then
    print("FAIL", "red")
    term.write("FATA", "red")
    print("[0016] Failed to parse the APIs response")

    return false
  end

  -- parse the response
  local rj =  json:decode(r.readAll())

  r.close() -- close the handle
  if rj ~= nil then
    if rj.success == true then
      print("OK", "green")
    else
      print("FAIL", "red")
      term.write("FATA", "red")
      print("[" .. (rj.code or tostring("0011")) .. "] Error: "..rj.error)

      return false
    end
  else
    print("FAIL", "red")
    term.write("FATA", "red")
    print("[0014] Failed to parse the APIs response.")

    return false
  end

  term.write("verifying it was uploaded ... ")
  print("OK", "green")

  return true
end

local function register(url)
  -- use fs.combine to make parsing a bit easier.
  local url = "http://" .. fs.combine(tostring(url), "")
  local apiv = http.get(url.."/api/version")

  if apiv == nil then
    term.write("FATA", "red")
    print("[0001] Couldn't communicate with the API.")

    return false
  end

  term.write("Username: ", "lightGray")
  local un = read()

  term.write("Password: ", "lightGray")
  local pass = read("*")

  term.write("Confirm Password: ", "lightGray")
  local charpass = read("*")

  if pass ~= charpass then
    term.write("FATA", "red")
    print("[0000] Passwords do not match.")

    return false
  end

  term.write("attempting to register ... ")
  local r = http.post(url.."/register", json:encode({
    username = un,
    password = sha256(pass)
  }))

  local rj =  json:decode(r.readAll())

  if rj == nil then
    print("FAIL", "red")
    term.write("FATA", "red")
    print("[0015] Failed to parse the APIs response")

    return false
  end

  r.close() -- close the handle
  if rj ~= nil then
    if rj.success == true then
      print("OK", "green")
    else
      print("FAIL", "red")
      term.write("FATA", "red")
      print("[" .. (rj.code or '0011') .. "] Error: "..rj.error)

      return false
    end
  else
    print("FAIL", "red")
    term.write("FATA", "red")
    print("[0013] Failed to parse the APIs response.")

    return false
  end

end

local function runImage(server, image)
  if image == nil then
    error("missing param 1 (image)")
  end

  if fs.exists(image) == false then
    local v = string.match(image, ".+:([0-9\.a-zA-Z]+)")
    local s = string.match(image, "(.+):[0-9\.a-zA-Z]+")
    local user = string.match(s, "(.+)/.+")
    local img = string.match(s, ".+/(.+)")

    if fs.exists("/var/ccdocker/"..user.."/"..img.."/"..v.."/docker.fs") == false then
      print("Unable to find image '"..image.."' locally.")
      if pullImage(server, image) ~= true then
        return false
      end
    else
      term.write("NOTI", "cyan")
      print("[0002] Image exists locally.")
    end

    docker.chroot(docker, "/var/ccdocker/"..user.."/"..img.."/"..v.."/docker.fs")
  else
    docker.chroot(docker, image)
  end

  return true -- probably all went well.
end

if Args[1] == nil then
  doHelp()
  return
end

if Args[1] == "pull" then
  pullImage(server, Args[2])
elseif Args[1] == "push" then
  pushImage(server, Args[2])
elseif Args[1] == "run" then
  runImage(server, Args[2])
elseif Args[1] == "version" then
  print(docker.version)
elseif Args[1] == "build" then
  buildImage(Args[2])
elseif Args[1] == "register" then
  register(server)
elseif Args[1] == "rmi"  then
  removeImage(server, Args[2])
elseif Args[1] == "help" then
  doHelp()
  return
else
  doHelp()
end
